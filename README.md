# Erik Kimsey : Frontend Engineer
## Simple Thread : Technical Challenge

## <br> [Completed Challenge on Repl.it](https://replit.com/@ErikKimsey/simplethread#index.js)</br> After the URL loads in Repl.it, press "Run" (green button at the top-center of page) and the output will be seen in the "Console" panel.

Hello!

As I mentioned in an email, to Al: 

My intention was to develop and integrate the technical challenge's logic into a Vue app.  The latter of which was an ambitious (and, tad naive) attempt to impress Simple Thread with my ability to "learn on the fly" - my experience is primarily in React and vanilla Javascript.  

In this repo, I made particular effort to be transparent and thorough in documenting my approach and thought process.  Which should be apparent in changes I had made to the code and comments therein.   

However, while preparing dinner the other evening, on an altogether different laptop, I decided I'd use Repl.it as a sort of sketchpad to think through aspects of the challenge's core logic.  One thing led to another, having fallen into "the zone", I restarted and completed the challenge in Repl.it.  In so doing, losing sight of Al's request that I commit stages of my progress, for assessment.  

*That being said, prior to Repl.it, again, I had made efforts to document my  thoughts in this repo.*  And, having reviewed this repo's notes and progress, what's here loosely reflects how I proceeded.

I very much regret having lost sight of Al's request to document my progress.  For what it's worth, as an after-the-fact effort, I have described my process in completing this challenge, below.  

Despite everything, and regardless of outcome, I am excited to have been invited to complete this challenge!  Thank you!

Please let me know if I can provide you with anything.  I look forward to hearing from you!

<br>Warm regards,</br>
<br>Erik Kimsey</br>
erikkimsey.github.io




##
### Colored with a bit of candor, I have made a list-ditch effort to provide further transparency to my process in completing this challenge:
1. Read and re-read the problem's/project's parameters.  
(1.5.  Then, I panic a bit, before gathering myself up.)
2. I break the project down into less intimidating pieces and begin pseudo-coding in comments within the file I intend to code my solution.
3. I, again, read the problem description and parameters in order to judge that, again, my pseudo-code accounts for the rules as I understand them.
4. I reflect on where I've seen similar problems and how I, or others, have approached such a problem.  (e.g., Which data structures and algorithms would make the most sense, result in increased performance, and yet cater to readability.)
5. I begin coding between the commented steps of pseudo-code.
6. I run the code to make sure those steps work as intended, thus far. If I'm not seeing the result I need, I refactor and debug.
7. Then, I repeat steps 3-5: making a little progress, running the code, and finessing or correcting code/pseudo-code where appropriate.
(7.5. I panic a little bit more, question my life choices, question how naive my code appears, and wrestle with a bit of imposter syndrome.) 
8. Again, I look at my progress thus far and question how I could improve Big-O and readability.  And, I then refactor where improvements can be made.
9. I repeat steps 3-7.(9.5. Finally, I see the light at the end of the tunnel and realize that it had actually been fun.)
10. If I am seeing the intended result from running the code, I begin cleaning up all of the unused methods, properties, and comments I've left in the code.
11. In the headlights of a close, oncoming deadline: Where I can very quickly improve performance and readability without breaking everything, I refactor for those improvements.  





##
### To paint a broader picture of myself, I have a personal manifesto, of sorts: 
(Which, seeing it typed out, reads as a little melodramatic.)
* I use a language's or framework's inherent methods and properties as much as possible, so as to keep things DRY.  I like to lean on the engineers that maintain languages and established frameworks, trusting they've taken into account the best possible performance and safety while engineering their product.
* If I use packages (e.g., npm), I research the package's dependencies and their dependencies' dependencies.  If a package has more than 3 dependencies, I likely do not use it.  
* I do a lot of Googling.  I like to remind myself of, or learn, principles pertaining to solving certain problems, and see solutions others have made for similar problems.
* I adhere to SOLID as much as possible.
* I sincerely listen to clients and make serious effort to communicate and understand their vision and purpose. For example, while working with UVa on SkillSTAR, I dove into research on autism and methods of education.
* As a Frontend Engineer, I research UX principles and innovations, and tie in my own insights and experiences.  The user comes first.
* As a Frontend Engineer, I am keen to aesthetics (i.e., color theory, and the psychology of color and form), UI/interaction and graphic design principles, design trends, and I take a good designer very seriously.
* As a Frontend Engineer, I am always aware of accessibility concerns.  That's not to say that I don't pout if accessibility-concerns interfere with what I consider an awesome aesthetic experience.  
